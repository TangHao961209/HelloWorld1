git学习：
       git push出现 ：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。
       git log 查看与远程是否没有更新代码

       git reset本地与远程最新的一笔
	   git  stash save  保存本地修改 ==>git status . 红颜色的就是本地修改
       git pull origin master   更新代码，与远程保持一致
       git stash pop    如果有冲突，本地解决冲突
       git add
       git commit -m
       git push origin master
       
    git拉取另一分支代码
    git clone -b branchname   xxxxx   
android.bp学习：
	   加宏，对应的地方添加cflags:-D   
android.mk学习:	   
	include $(call all-subdir-makefiles)  返回一个位于当前'my-dir'路径的子目录列表。
	只有动态库可以被 install/copy到应用程序包(APK). 静态库则可以被链接入动态库。
	LOCAL_PATH := $(call my-dir) 用于返回Android.mk所在目录的路径。
	   
shell学习：
	   建议软连接  sudo ln -s  源文件 目标文件      
	   sudo ln -s sudo ln -s   /usr/local/python3.7/bin/python3.7         /usr/bin/python
Camera Provider	   
在Treble架构下，存在了3个binder设备，分别是/dev/binder、/dev/vndbinder、/dev/hwbinder，上层需要通过binder库来访问这些binder设备，而/dev/binder和/dev/vndbinder都是由libbinder来访问，因此需要指定打开的binder设备。
		android::ProcessState::initWithDriver("/dev/vndbinder");   
		
CameraProvider_2_4.cpp的HIDL_FETCH_ICameraProvider函数根据instance获取调用不同的provider方法
legacy/0  ==> getProviderImpl<LegacyCameraProviderImpl_2_4>()
																 ==>CameraProvider<IMPL> *provider = new CameraProvider<IMPL>();		
external/0  ==> getProviderImpl<ExternalCameraProviderImpl_2_4>()
CameraProvider() : impl() {}  ==>调用对应的instance构造函数LegacyCameraProviderImpl_2_4.cpp
LegacyCameraProviderImpl_2_4.cpp的构造函数调用了==>initialize()==>下面的代码

camera_module_t *rawModule;
    int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,
            (const hw_module_t **)&rawModule);
    if (err < 0) {
        ALOGE("Could not load camera HAL module: %d (%s)", err, strerror(-err));
        return true;
    }

    mModule = new CameraModule(rawModule);
    err = mModule->init();	  ==>调用了camera_module_t结构体中的init函数

最后调用registerReference(fqName, name)向hwservicemanager注册。    



==============================0506=========================
HAL V3与V1最大的本质区别，我认为就是把帧的参数和帧的图像数据绑定到了一起，比如V1的时候一张preview上来的YUV帧，
APP是不知道这个YUV帧采用的Gain和曝光时间究竟是多少。但是在V3里面，每一帧都有一个数据结构来描述，其中包括了帧的
参数和帧的数据，当APP发送一个request的时候是需要指定使用什么样的参数，到request返回的时候，返回数据中就有图像
数据和相关的参数配置。
CameraService.cpp 的CameraService::onFirstRef  ==> enumerateProviders() ==> mCameraProviderManager->setUpVendorTags();
加载vendor tag
 // Setup vendor tags before we call get_camera_info the first time
 // because HAL might need to setup static vendor keys in get_camera_info
 // TODO: maybe put this into CameraProviderManager::initialize()?
        mCameraProviderManager->setUpVendorTags();
        
QCamera3VendorTags.cpp的get_vendor_tag_ops 完成/system/media/camera/include/system/camera_vendor_tags.h 的vendor_tag_ops_t结构体的映射；
结构体中的函数在    QCamera3VendorTags.cpp中实现。

get_tag_count;  //返回vendor tag的个数，有多少个返回多少个
get_all_tags;  //把所有vendor tag挨个放在service传下来的uint32_t * tag_array里面，这样上层就知道每一个tag对应的序号值了
get_section_name;//获取vendor tag的section对应的section名称，比如可以把某几个tag放在一个section里面，其它的放在其它的section里面.
get_tag_name用于获取每一个tag的名称
get_tag_type这个函数返回tag对应的设置数据的类型，可以用TYPE_INT32， TYPE_FLOAT等多种数据格式，取决于需求

参数传递
Parameters::updateRequest  ==> res = request->update(ANDROID_LED_TRANSMIT,
                                      &transmitDefault, 1);
CameraMetadat.h 调用了update函数  ==>最终调用 CameraMetadata::updateImpl
==>最终调用update_camera_metadata_entry或者add_camera_metadata_entry是
通过find_camera_metadata_entry看该TAG是否存在
 /**
     * Update metadata entry. Will create entry if it doesn't exist already, and
     * will reallocate the buffer if insufficient space exists. Overloaded for
     * the various types of valid data.
     */       
     
在QCamera3VendorTags.cpp中通过struct tag_info_t来维护一个tag的相关属性     
typedef struct vendor_tag_info {
    const char *tag_name;
    uint8_t     tag_type;
} vendor_tag_info_t; 
其中tag_name为对应section下不同tag的name值 ，tag_type指定了这个tag所维护的数据类型。
enum {
    // Unsigned 8-bit integer (uint8_t)
    TYPE_BYTE = 0,
    // Signed 32-bit integer (int32_t)
    TYPE_INT32 = 1,
    // 32-bit float (float)
    TYPE_FLOAT = 2,
    // Signed 64-bit integer (int64_t)
    TYPE_INT64 = 3,
    // 64-bit float (double)
    TYPE_DOUBLE = 4,
    // A 64-bit fraction (camera_metadata_rational_t)
    TYPE_RATIONAL = 5,
    // Number of type fields
    NUM_TYPES
};    
一个section中的tag以vendor_tag_info_t数组维护
vendor_tag_info_t qcamera3_cds[QCAMERA3_CDS_END - QCAMERA3_CDS_START] = {
    { "cds_mode", TYPE_INT32 },
    { "cds_info", TYPE_BYTE }
};                        
 
 CameraMetadata通过camera_metadata来维护数据信息
camera_metadata_t 结构体定义 /hardware/libhardware/include/hardware/camera_common.h 最初定义==>
/system/media/camera/include/system/camera_metadata.h      
一个CameraMetadata数据内存块中组成的最小基本单元是struct camera_metadata_buffer_entry，总的entry数目等信息需要struct camera_metadata_t来维护：
/system/media/camera/src/camera_metadata.c 的camera_metadata结构体
struct camera_metadata {
    metadata_size_t          size;
    uint32_t                 version;
    uint32_t                 flags;
    metadata_size_t          entry_count;//当前实际的entry数目
    metadata_size_t          entry_capacity;//entry最大可以存储的数目
    metadata_uptrdiff_t      entries_start; // Offset from camera_metadata
    metadata_size_t          data_count;//当前占据的数据空间
    metadata_size_t          data_capacity;//最大可操作的数据容量
    metadata_uptrdiff_t      data_start; // Offset from camera_metadata
    uint32_t                 padding;    // padding to 8 bytes boundary
    metadata_vendor_id_t     vendor_id;
};   

对于每一个entry主要记录他的所代表的TAG，以及这个TAG的需要存储的数据类型，此外还需要记录这个entry是否是需要一个union offset来表示他当前数据量过大时的数据存储位置                             
59/**
60 * A packet of metadata. This is a list of entries, each of which may point to
61 * its values stored at an offset in data.
62 *
63 * It is assumed by the utility functions that the memory layout of the packet
64 * is as follows:
65 *
66 *   |-----------------------------------------------|
67 *   | camera_metadata_t                             |
68 *   |                                               |
69 *   |-----------------------------------------------|
70 *   | reserved for future expansion                 |
71 *   |-----------------------------------------------|
72 *   | camera_metadata_buffer_entry_t #0             |
73 *   |-----------------------------------------------|
74 *   | ....                                          |
75 *   |-----------------------------------------------|
76 *   | camera_metadata_buffer_entry_t #entry_count-1 |
77 *   |-----------------------------------------------|
78 *   | free space for                                |
79 *   | (entry_capacity-entry_count) entries          |
80 *   |-----------------------------------------------|
81 *   | start of camera_metadata.data                 |
82 *   |                                               |
83 *   |-----------------------------------------------|
84 *   | free space for                                |
85 *   | (data_capacity-data_count) bytes              |
86 *   |-----------------------------------------------|
87 *
88 * With the total length of the whole packet being camera_metadata.size bytes.
89 *
90 * In short, the entries and data are contiguous in memory after the metadata
91 * header.
92 */    	
typedef struct camera_metadata_buffer_entry {
    uint32_t tag;//表示当时这个entry代表的tag值，即上文提到的section中不同的tag index值
    size_t   count;
    union {
        size_t  offset;
        uint8_t value[4];
    } data;//如果存储的数据量不大于4则直接存储。否则需要指点一个offset来表示便宜
    uint8_t  type;//维护的数据类型
    uint8_t  reserved[3];
} camera_metadata_buffer_entry_t;

======================================================
makefile 
PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))  ==>获取makefile所在目录的绝对路径
